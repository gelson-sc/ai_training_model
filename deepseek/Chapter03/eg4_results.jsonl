{
  "label": "good_prompt",
  "prompt": "Analyze the security vulnerabilities in this code snippet.\nFocus on SQL injection and authentication bypass.\nCode:\nfrom flask import Flask, request, session\nimport sqlite3, hashlib\n\napp = Flask(__name__)\napp.secret_key = \"dev\"\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    remember = request.form.get(\"remember\", \"0\")\n\n    # SQL injection risk: direct string interpolation of user input\n    conn = get_db()\n    cur = conn.cursor()\n    query = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n    cur.execute(query)\n    row = cur.fetchone()\n\n    if row:\n        # Weak check: truncated hash comparison can be abused\n        hashed = hashlib.sha256(password.encode()).hexdigest()\n        if hashed[:10] == row[1][:10]:\n            session[\"user_id\"] = row[0]\n            # Auth bypass risk: 'remember' flag grants admin privileges\n            if remember == \"1\":\n                session[\"is_admin\"] = True\n            return \"OK\"\n    return \"Unauthorized\", 401",
  "result": {
    "text": "The code snippet contains several critical security vulnerabilities, primarily related to SQL injection and authentication bypass. Here's a detailed analysis:\n\n### 1. **SQL Injection** (Critical)\n   - **Location**: `query = f\"SELECT ... WHERE username = '{username}'\"`\n   - **Vulnerability**: Direct string interpolation of user-controlled `username` into SQL.\n   - **Exploit**: \n     - Attacker inputs `' OR 1=1 -- ` as username:\n       ```sql\n       SELECT id, password_hash FROM users WHERE username = '' OR 1=1 -- '\n       ```\n     - This returns the first user in the database, bypassing authentication.\n   - **Impact**: Full authentication bypass and potential database compromise.\n   - **Fix**: Use parameterized queries:\n     ```python\n     query = \"SELECT id, password_hash FROM users WHERE username = ?\"\n     cur.execute(query, (username,))\n     ```\n\n### 2. **Authentication Bypass via Truncated Hash** (High)\n   - **Location**: `hashed[:10] == row[1][:10]`\n   - **Vulnerability**:\n     - Compares only the first 10 characters of the SHA-256 hash.\n     - SHA-256 truncated to 10 hex chars = **40 bits** (easily brute-forced).\n   - **Exploit**:\n     - Attacker finds *any* password with matching first 10 hash chars (collision attack).\n     - Example: If stored hash is `5d41402a4c`..., attacker finds password with hash `5d41402a4c...` (collision in 40 bits).\n   - **Impact**: Account takeover without knowing the real password.\n   - **Fix**: Compare full hashes and use proper password hashing:\n     ```python\n     if hashed == row[1]:  # Compare full hashes\n     ```\n     **Better**: Use dedicated password hashing (e.g., bcrypt).\n\n### 3. **Privilege Escalation via 'Remember' Flag** (High)\n   - **Location**: `if remember == \"1\": session[\"is_admin\"] = True`\n   - **Vulnerability**:\n     - User-controlled `remember` flag directly grants admin privileges.\n     - No validation against actual user role in the database.\n   - **Exploit**:\n     - Attacker sets `remember=1` during login to become admin.\n     - Works even for non-admin users.\n   - **Impact**: Unauthorized privilege escalation to admin.\n   - **Fix**: Store/admin status in the database and fetch it:\n     ```python\n     # In SQL: SELECT ..., is_admin FROM users ...\n     session[\"is_admin\"] = bool(row[2])  # row[2] = is_admin from DB\n     ```\n\n### 4. **Weak Password Hashing** (Medium)\n   - **Location**: `hashlib.sha256(password.encode()).hexdigest()`\n   - **Vulnerability**:\n     - SHA-256 is too fast for password hashing (vulnerable to GPU brute-forcing).\n     - No salt used (enables rainbow tables).\n   - **Impact**: Easier password cracking if DB is compromised.\n   - **Fix**: Use adaptive hashing (e.g., bcrypt or Argon2):\n     ```python\n     import bcrypt\n     # Storing: bcrypt.hashpw(password.encode(), bcrypt.gensalt())\n     # Checking: bcrypt.checkpw(password.encode(), stored_hash)\n     ```\n\n### 5. **Hardcoded Secret Key** (Low)\n   - **Location**: `app.secret_key = \"dev\"`\n   - **Vulnerability**: Predictable secret enables session hijacking.\n   - **Fix**: Use a strong, random secret stored in environment variables.\n\n---\n\n### Summary of Fixes:\n1. **SQL Injection** → Use parameterized queries.\n2. **Truncated Hash** → Compare full hashes; switch to bcrypt.\n3. **'Remember' Flag** → Store admin status in DB.\n4. **Weak Hashing** → Use bcrypt/Argon2 with salts.\n5. **Secret Key** → Generate a strong random key.\n\n### Fixed Code:\n```python\nfrom flask import Flask, request, session\nimport sqlite3, bcrypt  # Changed to bcrypt\nimport os\n\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SECRET_KEY\")  # Strong random key\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    # 'remember' flag removed from privilege logic\n\n    conn = get_db()\n    cur = conn.cursor()\n    # Parameterized query to prevent SQLi\n    cur.execute(\"SELECT id, password_hash, is_admin FROM users WHERE username = ?\", (username,))\n    row = cur.fetchone()\n\n    if row:\n        user_id, stored_hash, is_admin = row\n        # Verify password with bcrypt\n        if bcrypt.checkpw(password.encode(), stored_hash.encode()):\n            session[\"user_id\"] = user_id\n            session[\"is_admin\"] = bool(is_admin)  # From DB, not user input\n            return \"OK\"\n    return \"Unauthorized\", 401\n```\n\nThis addresses all critical vulnerabilities while maintaining functionality.",
    "latency_seconds": 54.33,
    "usage": {
      "prompt_tokens": 276,
      "completion_tokens": 2559,
      "total_tokens": 2835
    }
  },
  "metrics": {
    "mentions_sql": true,
    "mentions_auth_bypass": true,
    "target_hits": 28,
    "offtopic_hits": 1,
    "focus_score": 27,
    "snr": 0.342,
    "length_words": 532,
    "sentences": 38
  }
}
{
  "label": "bad_prompt",
  "prompt": "You are an expert security researcher with 20 years of experience. I want you to carefully examine the following code, thinking about all possible security issues. Consider things like SQL injection, XSS, CSRF, SSRF, RCE, XXE, authentication problems, cryptographic mistakes, logging leaks, supply-chain risks, misconfigurations, container isolation, and any other vulnerabilities. Provide detailed step-by-step reasoning, multiple attack scenarios, extensive mitigation guidance, references to standards, and discuss broader architectural concerns. Include lists and severity scoring. Here is the code:\nfrom flask import Flask, request, session\nimport sqlite3, hashlib\n\napp = Flask(__name__)\napp.secret_key = \"dev\"\n\ndef get_db():\n    return sqlite3.connect(\"app.db\")\n\n@app.route(\"/login\", methods=[\"POST\"])\ndef login():\n    username = request.form.get(\"username\", \"\")\n    password = request.form.get(\"password\", \"\")\n    remember = request.form.get(\"remember\", \"0\")\n\n    # SQL injection risk: direct string interpolation of user input\n    conn = get_db()\n    cur = conn.cursor()\n    query = f\"SELECT id, password_hash FROM users WHERE username = '{username}'\"\n    cur.execute(query)\n    row = cur.fetchone()\n\n    if row:\n        # Weak check: truncated hash comparison can be abused\n        hashed = hashlib.sha256(password.encode()).hexdigest()\n        if hashed[:10] == row[1][:10]:\n            session[\"user_id\"] = row[0]\n            # Auth bypass risk: 'remember' flag grants admin privileges\n            if remember == \"1\":\n                session[\"is_admin\"] = True\n            return \"OK\"\n    return \"Unauthorized\", 401",
  "result": {
    "text": "### Security Analysis of Flask Login Endpoint\n\nI've identified multiple critical vulnerabilities in the provided code. Below is a comprehensive breakdown:\n\n---\n\n#### **1. SQL Injection (Critical)**\n- **Vulnerability**: Direct string interpolation in SQL query\n- **Location**: `query = f\"SELECT ... WHERE username = '{username}'\"`\n- **Attack Scenario**:\n  - Attacker inputs `admin'--` as username: `SELECT ... WHERE username = 'admin'--'` (bypasses password check)\n  - Attacker inputs `' OR 1=1--` to log in as first user in table\n- **Severity**: CVSS 9.8 (Critical)\n- **Impact**: Full database",
    "latency_seconds": 61.59,
    "usage": {
      "prompt_tokens": 368,
      "completion_tokens": 2930,
      "total_tokens": 3298
    }
  },
  "metrics": {
    "mentions_sql": true,
    "mentions_auth_bypass": false,
    "target_hits": 1,
    "offtopic_hits": 0,
    "focus_score": 1,
    "snr": 0.2,
    "length_words": 74,
    "sentences": 5
  }
}
